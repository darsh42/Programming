#PURPOSE: CONVER DOCUMENT TO UPPERCASE
#
#
#
#
#PROCESSING: 1) OPEN INPUT FILE
#            2) OPEN THE OUTPUT FILE
#            4) WHILE WE'RE NOT AT THE END OF INPUT FILE
#               A) READ FILE INTO BUFFER
#               B) GO THROUGH EACH BYTE OF MEMORY
#                    IF THE BYTE IS LOWERCASE LETTER,
#                    CONVERT IT TO UPPER-CASE
#               C) WRITE THE MEMORY BUFFER TO OUTPUT
#

    .SECTION .DATA
    # ####### CONSTANTS ######## ;;
    .EQU SYS_OPEN, 5
    .EQU SYS_WRITE, 4
    .EQU SYS_READ, 3
    .EQU SYS_CLOSE, 6
    .EQU SYS_EXIT, 1

    # OPTIONS FOR OPEN
    # /USR/INCLUDE/ASM/FCNTL.H
    .EQU O_RDONLY, 0
    .EQU O_CREAT_WRONLY_TRUNC, 03101

    # STANDARD FILE DESCRIPTORS
    .EQU STDIN, 0
    .EQU STDOUT, 1
    .EQU STDERR, 2

    # SYSTEM CALL INTERRUPT
    .EQU LINUX_SYSCALL, 0X80
    .EQU END_OF_FILE, 0
    .EQU NUMBER_ARGUMENTS, 2

    .SECTION .BSS
    # BUFFER - LOCATION WHERE DATA IS LOADED FROM FILE
    #          INTO BUFFER, THIS SHOULD NOT BE GREATER THAN
    #          16,000 FOR REASONS
    .EQU BUFFER_SIZE, 500
    .LCOMM BUFFER_DATA, BUFFER_SIZE

    .SECTION .TEXT

    # STACK POSITIONS
    .EQU ST_SIZE_RESERVE, 8
    .EQU ST_FD_IN, -4
    .EQU ST_FD_OUT, -8
    .EQU ST_ARGC, 0             # NUMEBR OF ARGUMENTS
    .EQU ST_ARGV_0, 4           # NAME OF PROGRAM
    .EQU ST_ARGV_1, 8           # INPUT FILENAME
    .EQU ST_ARGV_2, 12          # OUTPUT FILENAME

    .GLOBL _START
_START:
    # START PROGRAM ;;
    # SAVE STACK POINTER ;;
    MOVL %ESP, %EBP

    # ALLOCATE SPACE FOR FILE DESCRIPTORS ON STACK
    SUBL $ST_SIZE_RESERVE, %ESP

OPEN_FILES:
OPEN_FD_IN:
    # OPEN INPUT FILE ;;
    # SYS CALL IN %EAX
    MOVL $SYS_OPEN, %EAX

    #  INPUT FILENAME
    MOVL ST_ARGV_1(%EBP), %EBX

    # READ ONLY FLAG
    MOVL $O_RDONLY, %ECX

    # MOVE PERMISSION
    MOVL $0666, %EDX

    # SYS CALL LINUX
    INT $LINUX_SYSCALL

STORE_FD_IN:
    # SAVE FILE DESCRIPTOR
    MOVL %EAX, ST_FD_IN(%EBP)

OPEN_FD_OUT:
    #  OPEN OUTPUT FILE ;;
    MOVL $SYS_OPEN, %EAX

    MOVL ST_ARGV_2(%EBP), %EBX

    MOVL $O_CREAT_WRONLY_TRUNC, %ECX

    MOVL $0666, %EDX

    INT $LINUX_SYSCALL

    MOVL %EAX, ST_FD_OUT(%EBP)

READ_LOOP_BEGIN:

    #  READ BLOCK FROM SYSTEM
    MOVL $SYS_READ, %EAX

    # GET THE INPUT FILE DESCRIPTOR
    MOVL ST_FD_IN(%EBP), %EBX

    # SPECIFY THE BUFFER
    MOVL $BUFFER_DATA, %ECX

    # SPECIFY THE SIZE OF BUFFER
    MOVL $BUFFER_SIZE, %EDX

    # SYSCALL
    INT $LINUX_SYSCALL

    # EXIT IF END IS REACHED
    CMPL $END_OF_FILE, %EAX
    JLE END_LOOP

CONTINUE_READ_LOOP:
    # CONVERT BLOCK TO UPPER ;;
    # PARAMETER ;;
    PUSHL $BUFFER_DATA          # PUSH LOCATION OF BUFFER
    PUSHL %EAX                  # PUSH SIZE OF BUFFER, READ CALL RETURNS
                                # NUMBER OF BYTES READ BY SYSTEM
    CALL CONVERT_TO_UPPER       # CALL CONVERTER FUNCTION
    POPL %EAX                   # GET THE BUFFER SIZE BACK
                                # READ ONLY RETURNS THE NUMBER OF BYTES READ
    ADDL $4, %ESP               # RESET STACK POSITION

    # WRITEING BLOCK TO OUTPUT FILE;;
    MOVL %EAX, %EDX             # SIZE OF BUFFER
    MOVL $SYS_WRITE, %EAX       # WRITE SYS CALL
    MOVL ST_FD_OUT(%EBP), %EBX  # FILENAME
    MOVL $BUFFER_DATA, %ECX

    INT $LINUX_SYSCALL

    JMP READ_LOOP_BEGIN

END_LOOP:
    # CLOSE FILES ;;
    # NOTE:    NO NEED FOR ERROR CHECKING
    #          AS ERRORS DO NOT MEAN MUCH HERE

    MOVL $SYS_CLOSE, %EAX
    MOVL ST_FD_OUT(%EBP), %EBX
    INT $LINUX_SYSCALL

    MOVL $SYS_CLOSE, %EAX
    MOVL ST_FD_IN(%EBP), %EBX
    INT $LINUX_SYSCALL

    # EXIT ;;
    MOVL $SYS_EXIT, %EAX
    MOVL $0, %EBX
    INT $LINUX_SYSCALL

    # PURPOSE: FUNCTION DOES THE CONVERSION
    #
    #
    #
    # INPUT:    FIRST PARAM - LOCATION OF BLOCK
    #                        OF MEMORY
    #           SECOND PARAM - LENGTH OF BUFFER
    #
    # OUTPUT:   WILL OVERWRITE CURRENT BUFFER WITH
    #           UPPER-CASE CONVERSION
    #
    # VARIABLES:
    #          %EAX - BEGINNNING OF BUFFER
    #          %EBX - LENGTH OF BUFFER
    #          %EDI - CURRENT BUFFER OFFSET
    #          %CL  - CURRENT BYTE BEING EXAMINED
    #                  (FIRST PART OF %ECX)

    # COSTANTS ;;
    # BOUNDERY OF THE SEATCH
    .EQU LOWERCASE_A, 'A'
    .EQU LOWERCASE_Z, 'Z'
    # CONVERSIONS
    .EQU UPPER_CONVERSION, 'A' - 'A'

    # STACK STUFF ;;
    .EQU ST_BUFFER_LEN, 8       # LENGTH OF BUFFER
    .EQU ST_BUFFER, 12          # ACTUAL BUFFER

CONVERT_TO_UPPER:
    PUSHL %EBP
    MOVL %ESP, %EBP

    # SET VARIABLES ;;
    MOVL ST_BUFFER(%EBP), %EAX
    MOVL ST_BUFFER_LEN(%EBP), %EBX

    MOVL $0, %EDI               # INDEX IN BUFFER

    # IF BUFFER IS ZERO LENGTH
    #      LEAVE
    CMPL $0, %EBX
    JE END_CONVERT_LOOP

CONVERT_LOOP:
    # GET CURRENT BYTE
    MOVB (%EAX, %EDI, 1), %CL

    # GO TO NEXT BYTE UNLESS BETWEEN A-Z
    CMPB $LOWERCASE_A, %CL
    JL NEXT_BYTE
    CMPB $LOWERCASE_Z, %CL
    JG NEXT_BYTE

    # OTHERWISE CONVERT TO UPPERCASE
    ADDB $UPPER_CONVERSION, %CL
    # STORE NEW UPPER BYTE
    MOVB %CL, (%EAX, %EDI, 1)

NEXT_BYTE:
    INCL %EDI                   # INCREMENT INDEX
    CMPL %EDI, %EBX             # CHECK IF REACHED END OF BUFFER LENGTH
    JNE CONVERT_LOOP            # IF NOT LOOP

END_CONVERT_LOOP:
    # NO RETURN VALUE AS BUFFER MODIFIED
    MOVL %EBP, %ESP
    POPL %EBP
RET
